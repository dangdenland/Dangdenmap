<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ‘èŠåœ°åœ–</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <style>
        body { margin: 0; padding: 0; font-family: "Microsoft JhengHei", "Heiti TC", sans-serif; }
        #map { height: 100vh; width: 100vw; background-color: #f5f5f5; }
        
        .legend { background: rgba(255, 255, 255, 0.95); padding: 10px 15px; border-radius: 5px; border: 1px solid #bbb; box-shadow: 0 2px 5px rgba(0,0,0,0.1); font-size: 13px; max-height: 60vh; overflow-y: auto; line-height: 1.5; }
        .legend h4 { margin: 0 0 8px 0; font-size: 15px; border-bottom: 2px solid #666; padding-bottom: 5px; }
        .legend-item { display: flex; align-items: center; margin-bottom: 4px; }
        .legend-color { width: 16px; height: 16px; margin-right: 8px; border-radius: 50%; border: 1px solid #666; flex-shrink: 0; }
        .legend-line { width: 20px; height: 3px; margin-right: 8px; display: inline-block; vertical-align: middle; }
        
        .changelog-btn {
            position: absolute; top: 80px; left: 10px; z-index: 1000;
            background: white; border: 2px solid rgba(0,0,0,0.2); border-radius: 4px;
            padding: 5px 10px; font-size: 13px; font-weight: bold; color: #333;
            text-decoration: none; box-shadow: 0 1px 5px rgba(0,0,0,0.4);
            transition: 0.2s; display: flex; align-items: center;
        }
        .changelog-btn:hover { background: #f4f4f4; color: #007bff; }

        .grid-label { font-size: 10px; color: #999; white-space: nowrap; }
        .village-label-wrapper { background: transparent; border: none; }
        
        /* æ¨™ç±¤æ¨£å¼ä¿®æ­£ï¼šä½¿ç”¨ translate(-50%, -50%) ç¢ºä¿ä¸­å¿ƒé»å°é½Šåº§æ¨™ */
        .village-label-content { 
            position: absolute; 
            left: 0; top: 0; 
            transform: translate(-50%, -50%); /* ä¿®æ­£ä¸­å¿ƒé» */
            
            display: inline-block; width: max-content; min-width: 40px; box-sizing: border-box; 
            font-size: 12px; font-weight: bold; color: #000; background-color: #fff; 
            padding: 4px 8px; border: 1px solid #666; border-radius: 4px; 
            white-space: nowrap; text-align: center; box-shadow: 1px 1px 4px rgba(0,0,0,0.2); 
            cursor: move; z-index: 600; user-select: none; 
        }
        .village-label-content:hover { background-color: #f0f8ff; border-color: #007bff; z-index: 700; }
        
        .leaflet-popup-content { font-size: 14px; line-height: 1.6; }
        
        @media print { .leaflet-control-container, .changelog-btn { display: none !important; } #map { height: 100%; width: 100%; } }
    </style>
</head>
<body>

<div id="map"></div>
<a href="changelog.html" target="_blank" class="changelog-btn">ğŸ“œ æ›´æ–°ç´€éŒ„</a>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script src="config.js"></script>
<script src="data.js"></script>

<script>
    var safeSettings = (typeof mapSettings !== 'undefined') ? mapSettings : { imageName: "map_bg.jpg", minX: -2560, maxX: 8928, minY: -9728, maxY: 880 };
    var safeData = (typeof rawData !== 'undefined') ? rawData : [];

    const map = L.map('map', { crs: L.CRS.Simple, minZoom: -6, maxZoom: 3, zoomSnap: 0.5, attributionControl: false });
    
    const coordMap = {};
    safeData.forEach(v => { coordMap[v.name] = [-v.y, v.x]; });

    const hierarchy = {};
    safeData.forEach(v => {
        if (!hierarchy[v.prov]) hierarchy[v.prov] = {};
        if (!hierarchy[v.prov][v.county]) hierarchy[v.prov][v.county] = new Set();
        hierarchy[v.prov][v.county].add(v.dist || "ç›´è½„");
    });
    
    const districtColors = {}; 
    Object.keys(hierarchy).forEach(prov => {
        Object.keys(hierarchy[prov]).forEach(county => {
            const districts = Array.from(hierarchy[prov][county]).sort();
            const baseHue = (typeof countyHues !== 'undefined' && countyHues[county] !== undefined) ? countyHues[county] : 0;
            districts.forEach((dist, index) => {
                const key = `${county}-${dist}`;
                if (county === "æœªå®š") {
                    districtColors[key] = "#7f8c8d";
                } else {
                    const count = districts.length;
                    let lightness = 50;
                    if (count > 1) lightness = 35 + (index / (count - 1)) * 35; 
                    districtColors[key] = `hsl(${baseHue}, 80%, ${lightness}%)`;
                }
            });
        });
    });

    const villageLayer = L.layerGroup();
    const labelLayer = L.layerGroup(); 
    const leaderLineLayer = L.layerGroup();
    const gridLayer = L.layerGroup();
    const railwayLayer = L.layerGroup(); 
    const railwayConstructionLayer = L.layerGroup(); 

    let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
    safeData.forEach(v => {
        if (v.x < minX) minX = v.x; if (v.x > maxX) maxX = v.x;
        if (v.y < minY) minY = v.y; if (v.y > maxY) maxY = v.y;
    });
    const padding = 2000;
    const gridBounds = { minX: minX - padding, maxX: maxX + padding, minY: minY - padding, maxY: maxY + padding };

    function drawRailways(routes, style, layer) {
        if(!routes) return;
        routes.forEach(routeStr => {
            const stations = routeStr.split("-");
            const latLngs = [];
            stations.forEach(name => {
                if (coordMap[name]) latLngs.push(coordMap[name]);
            });
            if (latLngs.length > 1) L.polyline(latLngs, style).addTo(layer);
        });
    }
    if(typeof railwayRoutesData !== 'undefined') {
        drawRailways(railwayRoutesData.completed, { color: '#333', weight: 3, opacity: 0.8, lineCap: 'round', lineJoin: 'round' }, railwayLayer);
        drawRailways(railwayRoutesData.construction, { color: '#e67e22', weight: 3, opacity: 0.8, dashArray: '5, 10', lineCap: 'round' }, railwayConstructionLayer);
    }

    const bounds = [];
    const labelObjects = []; 

    safeData.forEach(v => {
        const latLng = [-v.y, v.x];
        bounds.push(latLng);
        const distKey = v.dist || "ç›´è½„";
        const color = districtColors[`${v.county}-${distKey}`] || "#333";
        
        let linkHtml = "";
        if (v.mapUrl) {
            linkHtml = `<div style="margin-top:12px; text-align:center;"><a href="${v.mapUrl}" target="_blank" style="display: inline-block; text-decoration: none; background-color: #007bff; color: white; padding: 6px 12px; border-radius: 4px; font-size: 12px; font-weight: bold; transition: background 0.2s;" onmouseover="this.style.backgroundColor='#0056b3'" onmouseout="this.style.backgroundColor='#007bff'">æŸ¥çœ‹æ‘èŠè»Œé“åœ– âœ</a></div>`;
        }
        
        const subName = v.en ? `<div style="font-size:12px; color:#888; margin-top:-2px;">${v.en}</div>` : "";
        const heightInfo = (v.h !== undefined) ? ` | é«˜åº¦: ${v.h}m` : "";
        const locationText = (v.county === "æœªå®š") ? `<span style="color:#999; font-style:italic;">(è¡Œæ”¿å€åŠƒæœªå®š)</span>` : `${v.prov}çœ ${v.pref}åºœ<br>${v.county}ç¸£ ${v.dist ? v.dist + 'éƒ¡' : '(ç›´è½„)'}`;

        const popupContent = `
            <div style="text-align:center; min-width: 160px;">
                <strong style="font-size:16px; display:block; margin-bottom:2px;">${v.name}</strong>${subName}
                <hr style="margin:5px 0; border:0; border-top:1px solid #ccc">
                <div style="color:#333; margin: 6px 0; line-height:1.5;">${locationText}</div>
                <div style="font-size:12px; color:#666;">åº§æ¨™: (${v.x}, ${v.y})${heightInfo}</div>
                ${linkHtml}
            </div>`;
        
        const marker = L.circleMarker(latLng, { radius: 5, fillColor: color, color: "#333", weight: 1, opacity: 1, fillOpacity: 1, zIndexOffset: 500 });
        marker.bindPopup(popupContent);
        villageLayer.addLayer(marker);

        // å¼•å°ç·šåˆå§‹åŒ–
        const leaderLine = L.polyline([latLng, latLng], { color: '#555', weight: 1.5, opacity: 0, interactive: false });
        leaderLineLayer.addLayer(leaderLine);

        // æ–‡å­—æ¨™ç±¤
        const labelMarker = L.marker(latLng, {
            icon: L.divIcon({ className: 'village-label-wrapper', html: `<div class="village-label-content">${v.name}</div>`, iconSize: [0, 0], iconAnchor: [0, 0] }),
            draggable: true, zIndexOffset: 600 
        });
        labelMarker.bindPopup(popupContent);
        
        labelMarker.on('drag', function(e) {
            const currentLabelLatLng = e.target.getLatLng();
            const originalDotLatLng = latLng;
            // æ›´æ–°å¼•å°ç·š
            leaderLine.setLatLngs([originalDotLatLng, currentLabelLatLng]);
            leaderLine.setStyle({opacity: 0.6});
            labelMarker.isManualMoved = true;
        });
        labelLayer.addLayer(labelMarker);

        labelObjects.push({
            marker: labelMarker,
            line: leaderLine,
            origin: latLng,
            name: v.name
        });
    });

    function updateLabels() {
        if(labelObjects.length === 0) return;
        const currentBounds = map.getBounds();

        // 1. é‡ç½®æœªç§»å‹•æ¨™ç±¤çš„ä½ç½®
        labelObjects.forEach(obj => {
            if (!obj.marker.isManualMoved) {
                obj.marker.setLatLng(obj.origin);
            }
        });

        // 2. ç²å–å¯è¦‹æ¨™ç±¤çš„åƒç´ åº§æ¨™
        const visibleLabels = [];
        labelObjects.forEach(obj => {
            if(currentBounds.contains(obj.marker.getLatLng())) {
                const pt = map.latLngToContainerPoint(obj.marker.getLatLng());
                visibleLabels.push({
                    obj: obj,
                    x: pt.x,
                    y: pt.y
                });
            }
        });

        // 3. æ¨æ“ æ¼”ç®—æ³• (åƒç´ ç©ºé–“)
        const minDist = 50; 
        for(let k=0; k<15; k++) {
            for(let i=0; i<visibleLabels.length; i++) {
                const a = visibleLabels[i];
                if(a.obj.marker.isManualMoved) continue;

                for(let j=i+1; j<visibleLabels.length; j++) {
                    const b = visibleLabels[j];
                    const dx = a.x - b.x;
                    const dy = a.y - b.y;
                    const distSq = dx*dx + dy*dy;

                    if(distSq < minDist * minDist) {
                        const dist = Math.sqrt(distSq) || 1;
                        const force = (minDist - dist) / 2;
                        const angle = Math.atan2(dy, dx);
                        const moveX = Math.cos(angle) * force;
                        const moveY = Math.sin(angle) * force;

                        if(!a.obj.marker.isManualMoved) { a.x += moveX; a.y += moveY; }
                        if(!b.obj.marker.isManualMoved) { b.x -= moveX; b.y -= moveY; }
                    }
                }
            }
        }

        // 4. å¥—ç”¨ä½ç½®ä¸¦ç¹ªè£½å¼•å°ç·š
        visibleLabels.forEach(item => {
            if(!item.obj.marker.isManualMoved) {
                const originPt = map.latLngToContainerPoint(item.obj.origin);
                const dx = item.x - originPt.x;
                const dy = item.y - originPt.y;
                const dist = Math.sqrt(dx*dx + dy*dy);

                const newLatLng = map.containerPointToLatLng([item.x, item.y]);
                item.obj.marker.setLatLng(newLatLng);
                
                // ä¿®æ­£ï¼šç•¶æ¨™ç±¤ä½ç§»è¶…é 15 åƒç´ æ™‚æ‰é¡¯ç¤ºå¼•å°ç·š
                if (dist > 15) {
                    item.obj.line.setLatLngs([item.obj.origin, newLatLng]);
                    item.obj.line.setStyle({opacity: 0.6});
                } else {
                    item.obj.line.setStyle({opacity: 0});
                }
            } else {
                // å·²æ‰‹å‹•ç§»å‹•çš„æ¨™ç±¤ï¼Œç·šæ®µä¹Ÿéœ€ä¿æŒ
                const currentLatLng = item.obj.marker.getLatLng();
                item.obj.line.setLatLngs([item.obj.origin, currentLatLng]);
                item.obj.line.setStyle({opacity: 0.6});
            }
        });
    }

    map.on('zoomend moveend', updateLabels);
    map.whenReady(() => setTimeout(updateLabels, 500));

    function drawGrid() {
        gridLayer.clearLayers();
        const zoom = map.getZoom();
        let step = zoom >= 1 ? 100 : (zoom >= -1 ? 500 : (zoom >= -3 ? 1000 : (zoom >= -5 ? 2000 : 5000)));
        const startX = Math.floor(gridBounds.minX / step) * step;
        const endX = Math.ceil(gridBounds.maxX / step) * step;
        const startY = Math.floor(gridBounds.minY / step) * step;
        const endY = Math.ceil(gridBounds.maxY / step) * step;
        const style = { color: '#ccc', weight: 1, dashArray: '4, 4' };
        for (let x = startX; x <= endX; x += step) {
            gridLayer.addLayer(L.polyline([[-startY, x], [-endY, x]], style));
            if (x >= gridBounds.minX && x <= gridBounds.maxX) gridLayer.addLayer(L.marker([-startY, x], { icon: L.divIcon({className: 'grid-label', html: x, iconAnchor: [0, -5], iconSize:[40,10]}), interactive: false }));
        }
        for (let y = startY; y <= endY; y += step) {
            const ly = -y;
            gridLayer.addLayer(L.polyline([[ly, startX], [ly, endX]], style));
            if (y >= gridBounds.minY && y <= gridBounds.maxY) gridLayer.addLayer(L.marker([ly, startX], { icon: L.divIcon({className: 'grid-label', html: y, iconAnchor: [30, 0], iconSize:[40,10]}), interactive: false }));
        }
    }
    drawGrid();
    map.on('zoomend', drawGrid);
    gridLayer.addTo(map);

    const mapImageLayer = L.imageOverlay(
        safeSettings.imageName, 
        [[-safeSettings.minY, safeSettings.minX], [-safeSettings.maxY, safeSettings.maxX]], 
        { opacity: 0.9, zIndex: -1 }
    );
    const blankLayer = L.layerGroup();
    blankLayer.addTo(map);

    const baseMaps = { "ç©ºç™½èƒŒæ™¯": blankLayer, "åœ°å½¢åœ–": mapImageLayer };
    const overlayMaps = {
        "æ‘èŠé»ä½": villageLayer, "æ‘èŠåç¨± (å¯æ‹–æ›³)": labelLayer, "å¼•å°ç·š": leaderLineLayer,
        "éµè·¯ (å·²é€šè»Š)": railwayLayer, "éµè·¯ (èˆˆå»ºä¸­)": railwayConstructionLayer, "åæ¨™æ ¼ç·š": gridLayer
    };
    villageLayer.addTo(map); labelLayer.addTo(map); leaderLineLayer.addTo(map);

    L.control.layers(baseMaps, overlayMaps, {collapsed: false}).addTo(map);
    if (bounds.length > 0) map.fitBounds(bounds, { padding: [50, 50] });

    const legend = L.control({position: 'bottomright'});
    legend.onAdd = function (map) {
        const div = L.DomUtil.create('div', 'legend');
        L.DomEvent.disableScrollPropagation(div);
        L.DomEvent.disableClickPropagation(div);
        
        div.innerHTML = "<h4>ğŸ—ºï¸ è¡Œæ”¿å€åŠƒ</h4>";
        const provOrder = ["ä¸­äº¬", "æµ·åŒ—", "æœªå®š"];
        
        provOrder.forEach(prov => {
            if (!hierarchy[prov]) return;
            let provColor = (prov === "ä¸­äº¬") ? "#d35400" : (prov === "æµ·åŒ—" ? "#2980b9" : "#333");
            div.innerHTML += `<div style="margin-top:8px; border-bottom:2px solid ${provColor}; padding-bottom:2px; font-weight:bold; color:${provColor}">${prov}${prov!=="æœªå®š"?"çœ":""}</div>`;

            Object.keys(hierarchy[prov]).forEach(county => {
                const districts = Array.from(hierarchy[prov][county]).sort();
                districts.forEach(dist => {
                    const key = `${county}-${dist}`;
                    const color = districtColors[key] || "#999";
                    let displayName = (county === "æœªå®š") ? "æœªå®šå€åŸŸ" : (!dist || dist === "ç›´è½„") ? `${county}ç¸£ (ç›´è½„)` : `${county}ç¸£ ${dist}éƒ¡`;
                    div.innerHTML += `<div class="legend-item"><i class="legend-color" style="background:${color}"></i><span>${displayName}</span></div>`;
                });
            });
        });

        div.innerHTML += "<hr style='margin:10px 0; border:0; border-top:1px solid #ccc'>";
        div.innerHTML += `<div class="legend-item"><span class="legend-line" style="background:#333"></span><span>éµè·¯ (å·²é€šè»Š)</span></div>`;
        div.innerHTML += `<div class="legend-item"><span class="legend-line" style="background:#e67e22; border-top: 3px dashed #e67e22; height:0; background:none;"></span><span>éµè·¯ (èˆˆå»ºä¸­)</span></div>`;
        return div;
    };
    legend.addTo(map);
</script>
</body>
</html>
