<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ‘èŠåœ°åœ– - ç²¾æº–æ ¼ç·šç‰ˆ</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <style>
        body { margin: 0; padding: 0; font-family: "Microsoft JhengHei", "Heiti TC", sans-serif; }
        #map { height: 100vh; width: 100vw; background-color: #f5f5f5; }
        
        .legend { background: rgba(255, 255, 255, 0.95); padding: 10px 15px; border-radius: 5px; border: 1px solid #bbb; box-shadow: 0 2px 5px rgba(0,0,0,0.1); font-size: 13px; max-height: 60vh; overflow-y: auto; line-height: 1.5; }
        .legend h4 { margin: 0 0 8px 0; font-size: 15px; border-bottom: 2px solid #666; padding-bottom: 5px; }
        .legend-item { display: flex; align-items: center; margin-bottom: 4px; }
        .legend-color { width: 16px; height: 16px; margin-right: 8px; border-radius: 50%; border: 1px solid #666; flex-shrink: 0; }
        .legend-line { width: 20px; height: 3px; margin-right: 8px; display: inline-block; vertical-align: middle; }
        
        .changelog-btn {
            position: absolute; top: 80px; left: 10px; z-index: 1000;
            background: white; border: 2px solid rgba(0,0,0,0.2); border-radius: 4px;
            padding: 5px 10px; font-size: 13px; font-weight: bold; color: #333;
            text-decoration: none; box-shadow: 0 1px 5px rgba(0,0,0,0.4);
            transition: 0.2s; display: flex; align-items: center;
        }
        .changelog-btn:hover { background: #f4f4f4; color: #007bff; }

        .grid-label { font-size: 10px; color: #888; white-space: nowrap; font-family: monospace; }
        .village-label-wrapper { background: transparent; border: none; }
        
        .village-label-content { 
            position: absolute; left: 0; top: 0; transform: translate(-50%, -50%);
            display: inline-block; width: max-content; min-width: 40px; box-sizing: border-box; 
            font-size: 12px; font-weight: bold; color: #000; background-color: rgba(255,255,255,0.9); 
            padding: 3px 7px; border: 1px solid #666; border-radius: 4px; 
            white-space: nowrap; text-align: center; box-shadow: 1px 1px 4px rgba(0,0,0,0.2); 
            cursor: move; z-index: 600; user-select: none; pointer-events: auto;
        }
        .village-label-content:hover { background-color: #fff; border-color: #007bff; z-index: 700; box-shadow: 0 0 8px rgba(0,123,255,0.5); }
        
        .leaflet-popup-content { font-size: 14px; line-height: 1.6; }
        @media print { .leaflet-control-container, .changelog-btn { display: none !important; } #map { height: 100%; width: 100%; } }
    </style>
</head>
<body>

<div id="map"></div>
<a href="changelog.html" target="_blank" class="changelog-btn">ğŸ“œ æ›´æ–°ç´€éŒ„</a>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script src="config.js"></script>
<script src="data.js"></script>

<script>
    // å–å¾—é…ç½®ï¼Œè‹¥ç„¡å‰‡ä½¿ç”¨é è¨­å€¼
    var safeSettings = (typeof mapSettings !== 'undefined') ? mapSettings : { imageName: "map_bg.jpg", minX: -5000, maxX: 10000, minY: -10000, maxY: 1000 };
    var safeData = (typeof rawData !== 'undefined') ? rawData : [];

    // åˆå§‹åŒ–åœ°åœ– (ä½¿ç”¨ CRS.Simple éŠæˆ²åº§æ¨™ç³»)
    const map = L.map('map', { crs: L.CRS.Simple, minZoom: -6, maxZoom: 4, zoomSnap: 0.1, attributionControl: false });
    
    // å¿«é€Ÿç´¢å¼•åº§æ¨™ç”¨
    const coordMap = {};
    safeData.forEach(v => { coordMap[v.name] = [-v.y, v.x]; });

    // å»ºç«‹è¡Œæ”¿å€åŠƒå±¤ç´š
    const hierarchy = {};
    safeData.forEach(v => {
        if (!hierarchy[v.prov]) hierarchy[v.prov] = {};
        if (!hierarchy[v.prov][v.county]) hierarchy[v.prov][v.county] = new Set();
        hierarchy[v.prov][v.county].add(v.dist || "ç›´è½„");
    });
    
    const districtColors = {}; 
    Object.keys(hierarchy).forEach(prov => {
        Object.keys(hierarchy[prov]).forEach(county => {
            const districts = Array.from(hierarchy[prov][county]).sort();
            const baseHue = (typeof countyHues !== 'undefined' && countyHues[county] !== undefined) ? countyHues[county] : 0;
            districts.forEach((dist, index) => {
                const key = `${county}-${dist}`;
                districtColors[key] = (county === "æœªå®š") ? "#7f8c8d" : `hsl(${baseHue}, 80%, ${districts.length > 1 ? 35 + (index / (districts.length - 1)) * 35 : 50}%)`;
            });
        });
    });

    // å®šç¾©åœ–å±¤çµ„
    const villageLayer = L.layerGroup().addTo(map);
    const labelLayer = L.layerGroup().addTo(map); 
    const leaderLineLayer = L.layerGroup().addTo(map);
    const gridLayer = L.layerGroup().addTo(map);
    const railwayLayer = L.layerGroup(); 
    const railwayConstructionLayer = L.layerGroup(); 

    // ç¹ªè£½éµè·¯
    function drawRailways(routes, style, layer) {
        if(!routes) return;
        routes.forEach(routeStr => {
            const stations = routeStr.split("-");
            const latLngs = [];
            stations.forEach(name => { if (coordMap[name]) latLngs.push(coordMap[name]); });
            if (latLngs.length > 1) L.polyline(latLngs, style).addTo(layer);
        });
    }
    if(typeof railwayRoutesData !== 'undefined') {
        drawRailways(railwayRoutesData.completed, { color: '#333', weight: 3, opacity: 0.8 }, railwayLayer);
        drawRailways(railwayRoutesData.construction, { color: '#e67e22', weight: 3, opacity: 0.8, dashArray: '5, 10' }, railwayConstructionLayer);
    }

    // å»ºç«‹æ‘èŠèˆ‡æ¨™ç±¤
    const bounds = [];
    const labelObjects = []; 

    safeData.forEach(v => {
        const latLng = [-v.y, v.x];
        bounds.push(latLng);
        const distKey = v.dist || "ç›´è½„";
        const color = districtColors[`${v.county}-${distKey}`] || "#333";
        
        const popupContent = `
            <div style="text-align:center; min-width: 160px;">
                <strong style="font-size:16px;">${v.name}</strong>
                <hr style="margin:5px 0; border-top:1px solid #ccc">
                <div style="font-size:12px;">${v.prov}çœ ${v.county}ç¸£ ${v.dist || '(ç›´è½„)'}</div>
                <div style="font-size:11px; color:#666; margin-top:4px;">åº§æ¨™: (${v.x}, ${v.y})</div>
                ${v.mapUrl ? `<div style="margin-top:8px;"><a href="${v.mapUrl}" target="_blank" style="color:#007bff; font-weight:bold; text-decoration:none;">æŸ¥çœ‹è»Œé“åœ– âœ</a></div>` : ''}
            </div>`;
        
        const marker = L.circleMarker(latLng, { radius: 5, fillColor: color, color: "#000", weight: 1.5, fillOpacity: 1 }).bindPopup(popupContent);
        villageLayer.addLayer(marker);

        const leaderLine = L.polyline([latLng, latLng], { color: '#666', weight: 1, opacity: 0, interactive: false });
        leaderLineLayer.addLayer(leaderLine);

        const labelMarker = L.marker(latLng, {
            icon: L.divIcon({ className: 'village-label-wrapper', html: `<div class="village-label-content">${v.name}</div>`, iconSize: [0, 0] }),
            draggable: true
        }).bindPopup(popupContent);
        
        labelMarker.on('drag', function(e) {
            leaderLine.setLatLngs([latLng, e.target.getLatLng()]);
            leaderLine.setStyle({opacity: 0.6});
            labelMarker.isManualMoved = true;
        });
        labelLayer.addLayer(labelMarker);

        labelObjects.push({ marker: labelMarker, line: leaderLine, origin: latLng });
    });

    // é¿è®“æ¼”ç®—æ³•ï¼šä¿®æ­£é«˜å€ç‡ä¸è¦†è“‹åœ“é»
    function updateLabels() {
        const currentBounds = map.getBounds();
        const visibleLabels = [];
        
        labelObjects.forEach(obj => {
            if(!obj.marker.isManualMoved) obj.marker.setLatLng(obj.origin);
            if(currentBounds.contains(obj.origin)) {
                const pt = map.latLngToContainerPoint(obj.origin);
                visibleLabels.push({ obj, x: pt.x, y: pt.y, ox: pt.x, oy: pt.y });
            }
        });

        const minDist = 45; 
        const forcePushFromCenter = 30; 

        for(let k=0; k<15; k++) {
            visibleLabels.forEach(a => {
                if(a.obj.marker.isManualMoved) return;
                const dxCenter = a.x - a.ox, dyCenter = a.y - a.oy;
                const distCenter = Math.sqrt(dxCenter*dxCenter + dyCenter*dyCenter);
                if (distCenter < forcePushFromCenter) {
                    if (distCenter < 1) { a.y -= 2; } 
                    else {
                        const ratio = forcePushFromCenter / distCenter;
                        a.x = a.ox + dxCenter * ratio; a.y = a.oy + dyCenter * ratio;
                    }
                }
                visibleLabels.forEach(b => {
                    if (a === b) return;
                    const dx = a.x - b.x, dy = a.y - b.y;
                    const d = Math.sqrt(dx*dx + dy*dy);
                    if (d < minDist) {
                        const s = (minDist - d) / 2;
                        const ax = (dx/d)*s, ay = (dy/d)*s;
                        a.x += ax; a.y += ay;
                        if(!b.obj.marker.isManualMoved) { b.x -= ax; b.y -= ay; }
                    }
                });
            });
        }

        visibleLabels.forEach(item => {
            const newLatLng = map.containerPointToLatLng([item.x, item.y]);
            if(!item.obj.marker.isManualMoved) item.obj.marker.setLatLng(newLatLng);
            const dist = map.latLngToContainerPoint(item.obj.marker.getLatLng()).distanceTo([item.ox, item.oy]);
            if (dist > 12) {
                item.obj.line.setLatLngs([item.obj.origin, item.obj.marker.getLatLng()]);
                item.obj.line.setStyle({opacity: 0.5});
            } else {
                item.obj.line.setStyle({opacity: 0});
            }
        });
    }

    // æ ¼ç·šç¹ªè£½ï¼šä¿®æ­£æ°´å¹³èˆ‡å‚ç›´å°é½Š
    function drawGrid() {
        gridLayer.clearLayers();
        const zoom = map.getZoom();
        let step = zoom >= 1 ? 100 : (zoom >= -1 ? 500 : (zoom >= -3 ? 1000 : 2000));
        
        // ä½¿ç”¨é…ç½®çš„é‚Šç•Œï¼Œä¸¦å¾€å¤–æ“´å……ä¸€é»ç¢ºä¿æ ¼ç·šè¦†è“‹å…¨è¢å¹•
        const b = {
            minX: safeSettings.minX - 2000,
            maxX: safeSettings.maxX + 2000,
            minY: safeSettings.minY - 2000,
            maxY: safeSettings.maxY + 2000
        };

        const gridStyle = { color: '#ccc', weight: 1, dashArray: '4, 4', opacity: 0.6 };

        // ç¹ªè£½å‚ç›´ç·š (å›ºå®š X)
        for (let x = Math.floor(b.minX / step) * step; x <= b.maxX; x += step) {
            gridLayer.addLayer(L.polyline([[-b.minY, x], [-b.maxY, x]], gridStyle));
            // åœ¨ä¸Šæ–¹æ¨™è¨» X åº§æ¨™
            gridLayer.addLayer(L.marker([-b.minY, x], { 
                icon: L.divIcon({ className: 'grid-label', html: x, iconAnchor: [0, 15], iconSize: [40, 10] }),
                interactive: false
            }));
        }

        // ç¹ªè£½æ°´å¹³ç·š (å›ºå®š Y)
        for (let y = Math.floor(b.minY / step) * step; y <= b.maxY; y += step) {
            gridLayer.addLayer(L.polyline([[-y, b.minX], [-y, b.maxX]], gridStyle));
            // åœ¨å·¦å´æ¨™è¨» Y åº§æ¨™
            gridLayer.addLayer(L.marker([-y, b.minX], { 
                icon: L.divIcon({ className: 'grid-label', html: y, iconAnchor: [45, 5], iconSize: [40, 10] }),
                interactive: false
            }));
        }
    }

    // äº‹ä»¶ç›£è½
    map.on('zoomend moveend', updateLabels);
    map.on('zoomend', drawGrid);
    map.whenReady(() => {
        setTimeout(updateLabels, 300);
        drawGrid();
    });

    // åœ–å±¤æ§åˆ¶
    const mapImageLayer = L.imageOverlay(safeSettings.imageName, [[-safeSettings.minY, safeSettings.minX], [-safeSettings.maxY, safeSettings.maxX]], { opacity: 0.85 });
    const blankLayer = L.layerGroup().addTo(map); // [ä¿®æ­£] é è¨­åŠ å…¥ç©ºç™½èƒŒæ™¯

    const baseMaps = { "ç©ºç™½èƒŒæ™¯": blankLayer, "åœ°å½¢åœ–": mapImageLayer };
    const overlayMaps = { 
        "æ‘èŠé»ä½": villageLayer, 
        "åç¨±æ¨™ç±¤": labelLayer, 
        "å¼•å°ç·š": leaderLineLayer, 
        "æ ¼ç·š": gridLayer, 
        "éµè·¯ (é€šè»Š)": railwayLayer.addTo(map), 
        "éµè·¯ (èˆˆå»º)": railwayConstructionLayer 
    };

    L.control.layers(baseMaps, overlayMaps, { collapsed: false }).addTo(map);

    // åˆå§‹è¦–è§’å®šä½
    if (bounds.length > 0) map.fitBounds(bounds, { padding: [50, 50] });

    // åœ–ä¾‹
    const legend = L.control({position: 'bottomright'});
    legend.onAdd = function () {
        const div = L.DomUtil.create('div', 'legend');
        div.innerHTML = "<h4>ğŸ—ºï¸ è¡Œæ”¿å€åŠƒ</h4>";
        ["ä¸­äº¬", "æµ·åŒ—", "æœªå®š"].forEach(prov => {
            if (!hierarchy[prov]) return;
            div.innerHTML += `<div style="font-weight:bold; color:${prov==='ä¸­äº¬'?'#d35400':'#2980b9'}; margin-top:5px;">${prov}çœ</div>`;
            Object.keys(hierarchy[prov]).forEach(county => {
                Array.from(hierarchy[prov][county]).forEach(dist => {
                    const color = districtColors[`${county}-${dist}`];
                    div.innerHTML += `<div class="legend-item"><i class="legend-color" style="background:${color}"></i>${county}ç¸£ ${dist==='ç›´è½„'?'(ç›´è½„)':dist+'éƒ¡'}</div>`;
                });
            });
        });
        return div;
    };
    legend.addTo(map);
</script>
</body>
</html>
