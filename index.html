<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ÊùëËéäÂú∞Âúñ - ÁâàÊú¨Ê™¢Ë¶ñÁâà</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <style>
        body { margin: 0; padding: 0; font-family: "Microsoft JhengHei", sans-serif; }
        #map { height: 100vh; width: 100vw; background-color: #f5f5f5; }
        
        .legend { background: rgba(255, 255, 255, 0.95); padding: 10px 15px; border-radius: 5px; border: 1px solid #bbb; box-shadow: 0 2px 5px rgba(0,0,0,0.1); font-size: 13px; max-height: 60vh; overflow-y: auto; }
        .legend h4 { margin: 0 0 8px 0; font-size: 15px; border-bottom: 2px solid #666; padding-bottom: 5px; }
        .legend-item { display: flex; align-items: center; margin-bottom: 4px; }
        .legend-color { width: 16px; height: 16px; margin-right: 8px; border-radius: 50%; border: 1px solid #666; flex-shrink: 0; }
        
        .changelog-btn {
            position: absolute; top: 80px; left: 10px; z-index: 1000;
            background: white; border: 2px solid rgba(0,0,0,0.2); border-radius: 4px;
            padding: 5px 10px; font-size: 13px; font-weight: bold; color: #333;
            text-decoration: none; box-shadow: 0 1px 5px rgba(0,0,0,0.4);
        }

        /* ÁâàÊú¨È°ØÁ§∫Ê®£Âºè */
        .version-badge {
            position: absolute; top: 120px; left: 10px; z-index: 1000;
            background: rgba(0, 0, 0, 0.7); color: #0f0;
            padding: 4px 8px; border-radius: 4px; font-size: 11px;
            font-family: monospace; pointer-events: none;
            border: 1px solid rgba(0, 255, 0, 0.3); box-shadow: 0 2px 5px rgba(0,0,0,0.5);
        }

        .grid-label { font-size: 10px; color: #888; white-space: nowrap; font-family: monospace; }
        .village-label-content { 
            position: absolute; transform: translate(-50%, -50%);
            display: inline-block; width: max-content; font-size: 12px; font-weight: bold; 
            background-color: rgba(255,255,255,0.9); padding: 3px 7px; border: 1px solid #666; 
            border-radius: 4px; box-shadow: 1px 1px 4px rgba(0,0,0,0.2); pointer-events: auto;
        }
    </style>
</head>
<body>

<div id="map"></div>
<a href="changelog.html" target="_blank" class="changelog-btn">üìú Êõ¥Êñ∞Á¥ÄÈåÑ</a>
<div id="version-display" class="version-badge">Ver: Loading...</div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script src="config.js"></script>
<script src="data.js"></script>

<script>
    var safeSettings = (typeof mapSettings !== 'undefined') ? mapSettings : { version: "Unknown", imageName: "map_bg.jpg", minX: -5000, maxX: 10000, minY: -10000, maxY: 1000 };
    var safeData = (typeof rawData !== 'undefined') ? rawData : [];

    // È°ØÁ§∫ÁâàÊú¨Ëôü
    document.getElementById('version-display').innerText = "Ver: " + (safeSettings.version || "Êú™Ë®≠ÂÆö");

    const map = L.map('map', { crs: L.CRS.Simple, minZoom: -6, maxZoom: 4, zoomSnap: 0.1, attributionControl: false });
    
    // ÂúñÂ±§ÂÆöÁæ©
    const villageLayer = L.layerGroup().addTo(map);
    const labelLayer = L.layerGroup().addTo(map); 
    const leaderLineLayer = L.layerGroup().addTo(map);
    const gridLayer = L.layerGroup().addTo(map);
    const railwayLayer = L.layerGroup().addTo(map);
    const railwayConstructionLayer = L.layerGroup();
    const blankLayer = L.layerGroup().addTo(map); // È†êË®≠Á©∫ÁôΩËÉåÊôØ

    const coordMap = {};
    safeData.forEach(v => { coordMap[v.name] = [-v.y, v.x]; });

    // Ë°åÊîøÂçÄÂäÉÈ°èËâ≤ËàáË≥áÊñôËôïÁêÜ (ÁúÅÁï•ÈáçË§áÈÇèËºØÔºå‰øùÊåÅËàáÂâçÁâà‰∏ÄËá¥)
    const hierarchy = {};
    safeData.forEach(v => {
        if (!hierarchy[v.prov]) hierarchy[v.prov] = {};
        if (!hierarchy[v.prov][v.county]) hierarchy[v.prov][v.county] = new Set();
        hierarchy[v.prov][v.county].add(v.dist || "Áõ¥ËΩÑ");
    });
    const districtColors = {};
    Object.keys(hierarchy).forEach(prov => {
        Object.keys(hierarchy[prov]).forEach(county => {
            const districts = Array.from(hierarchy[prov][county]).sort();
            const baseHue = (typeof countyHues !== 'undefined' && countyHues[county] !== undefined) ? countyHues[county] : 0;
            districts.forEach((dist, index) => {
                const key = `${county}-${dist}`;
                districtColors[key] = (county === "Êú™ÂÆö") ? "#7f8c8d" : `hsl(${baseHue}, 80%, 50%)`;
            });
        });
    });

    // Âª∫Á´ãÊùëËéäËàáÊ®ôÁ±§ÈÇèËºØ
    const labelObjects = [];
    const bounds = [];
    safeData.forEach(v => {
        const latLng = [-v.y, v.x];
        bounds.push(latLng);
        const color = districtColors[`${v.county}-${v.dist || "Áõ¥ËΩÑ"}`] || "#333";
        
        L.circleMarker(latLng, { radius: 5, fillColor: color, color: "#000", weight: 1.5, fillOpacity: 1 }).addTo(villageLayer);

        const leaderLine = L.polyline([latLng, latLng], { color: '#666', weight: 1, opacity: 0 }).addTo(leaderLineLayer);
        const labelMarker = L.marker(latLng, {
            icon: L.divIcon({ className: 'village-label-wrapper', html: `<div class="village-label-content">${v.name}</div>`, iconSize: [0, 0] }),
            draggable: true
        }).addTo(labelLayer);
        
        labelMarker.on('drag', function(e) {
            leaderLine.setLatLngs([latLng, e.target.getLatLng()]);
            leaderLine.setStyle({opacity: 0.6});
            labelMarker.isManualMoved = true;
        });
        labelObjects.push({ marker: labelMarker, line: leaderLine, origin: latLng });
    });

    // ÈÅøËÆìÊºîÁÆóÊ≥ï (Á¢∫‰øù‰∏çË¶ÜËìãÂúìÈªû)
    function updateLabels() {
        const currentBounds = map.getBounds();
        const visibleLabels = [];
        labelObjects.forEach(obj => {
            if(!obj.marker.isManualMoved) obj.marker.setLatLng(obj.origin);
            if(currentBounds.contains(obj.origin)) {
                const pt = map.latLngToContainerPoint(obj.origin);
                visibleLabels.push({ obj, x: pt.x, y: pt.y, ox: pt.x, oy: pt.y });
            }
        });
        const minDist = 45, forcePush = 30; 
        for(let k=0; k<15; k++) {
            visibleLabels.forEach(a => {
                if(a.obj.marker.isManualMoved) return;
                const dxC = a.x - a.ox, dyC = a.y - a.oy;
                const distC = Math.sqrt(dxC*dxC + dyC*dyC);
                if (distC < forcePush) {
                    a.y -= 2; // È†êË®≠ÂæÄ‰∏äÊé®
                }
                visibleLabels.forEach(b => {
                    if (a === b) return;
                    const dx = a.x - b.x, dy = a.y - b.y;
                    const d = Math.sqrt(dx*dx + dy*dy);
                    if (d < minDist) {
                        a.x += (dx/d)*2; a.y += (dy/d)*2;
                    }
                });
            });
        }
        visibleLabels.forEach(item => {
            const newLatLng = map.containerPointToLatLng([item.x, item.y]);
            if(!item.obj.marker.isManualMoved) item.obj.marker.setLatLng(newLatLng);
            if (map.latLngToContainerPoint(item.obj.marker.getLatLng()).distanceTo([item.ox, item.oy]) > 12) {
                item.obj.line.setLatLngs([item.obj.origin, item.obj.marker.getLatLng()]);
                item.obj.line.setStyle({opacity: 0.5});
            } else { item.obj.line.setStyle({opacity: 0}); }
        });
    }

    // Á≤æÊ∫ñÊ†ºÁ∑öÁπ™Ë£Ω
    function drawGrid() {
        gridLayer.clearLayers();
        const zoom = map.getZoom();
        let step = zoom >= 1 ? 100 : (zoom >= -1 ? 500 : 1000);
        const b = { minX: safeSettings.minX - 2000, maxX: safeSettings.maxX + 2000, minY: safeSettings.minY - 2000, maxY: safeSettings.maxY + 2000 };
        const gridStyle = { color: '#ccc', weight: 1, dashArray: '4, 4', opacity: 0.6 };
        for (let x = Math.floor(b.minX / step) * step; x <= b.maxX; x += step) {
            L.polyline([[-b.minY, x], [-b.maxY, x]], gridStyle).addTo(gridLayer);
            L.marker([-b.minY, x], { icon: L.divIcon({ className: 'grid-label', html: x, iconAnchor: [0, 15] }), interactive: false }).addTo(gridLayer);
        }
        for (let y = Math.floor(b.minY / step) * step; y <= b.maxY; y += step) {
            L.polyline([[-y, b.minX], [-y, b.maxX]], gridStyle).addTo(gridLayer);
            L.marker([-y, b.minX], { icon: L.divIcon({ className: 'grid-label', html: y, iconAnchor: [45, 5] }), interactive: false }).addTo(gridLayer);
        }
    }

    map.on('zoomend moveend', updateLabels);
    map.on('zoomend', drawGrid);
    map.whenReady(() => { drawGrid(); updateLabels(); if (bounds.length > 0) map.fitBounds(bounds, { padding: [50, 50] }); });

    const mapImageLayer = L.imageOverlay(safeSettings.imageName, [[-safeSettings.minY, safeSettings.minX], [-safeSettings.maxY, safeSettings.maxX]], { opacity: 0.85 });
    const baseMaps = { "Á©∫ÁôΩËÉåÊôØ": blankLayer, "Âú∞ÂΩ¢Âúñ": mapImageLayer };
    const overlayMaps = { "ÊùëËéäÈªû‰Ωç": villageLayer, "ÂêçÁ®±Ê®ôÁ±§": labelLayer, "Ê†ºÁ∑ö": gridLayer, "ÈêµË∑Ø": railwayLayer };
    L.control.layers(baseMaps, overlayMaps, { collapsed: false }).addTo(map);
</script>
</body>
</html>
