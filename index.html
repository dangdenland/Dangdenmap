<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ‘èŠåœ°åœ– - ç©©å®šä¿®å¾©ç‰ˆ</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <style>
        body { margin: 0; padding: 0; font-family: "Microsoft JhengHei", sans-serif; background-color: #f5f5f5; }
        #map { height: 100vh; width: 100vw; }
        .legend { background: rgba(255, 255, 255, 0.95); padding: 10px 15px; border-radius: 5px; border: 1px solid #bbb; box-shadow: 0 2px 5px rgba(0,0,0,0.1); font-size: 13px; max-height: 60vh; overflow-y: auto; }
        .legend h4 { margin: 0 0 8px 0; font-size: 15px; border-bottom: 2px solid #666; padding-bottom: 5px; }
        .legend-item { display: flex; align-items: center; margin-bottom: 4px; }
        .legend-color { width: 14px; height: 14px; margin-right: 8px; border-radius: 50%; border: 1px solid #666; flex-shrink: 0; }
        .changelog-btn { position: absolute; top: 80px; left: 10px; z-index: 1000; background: white; border: 2px solid rgba(0,0,0,0.2); border-radius: 4px; padding: 5px 10px; font-size: 13px; font-weight: bold; color: #333; text-decoration: none; }
        .version-badge { position: absolute; top: 120px; left: 10px; z-index: 1000; background: rgba(0, 0, 0, 0.7); color: #0f0; padding: 4px 8px; border-radius: 4px; font-size: 11px; font-family: monospace; border: 1px solid rgba(0, 255, 0, 0.3); }
        .grid-label { font-size: 10px; color: #888; font-family: monospace; text-shadow: 1px 1px 0 #fff; }
        .village-label-content { position: absolute; transform: translate(-50%, -50%); display: inline-block; font-size: 12px; font-weight: bold; background-color: rgba(255,255,255,0.95); padding: 3px 7px; border: 1px solid #666; border-radius: 4px; box-shadow: 1px 1px 4px rgba(0,0,0,0.2); pointer-events: auto; }
    </style>
</head>
<body>

<div id="map"></div>
<a href="changelog.html" target="_blank" class="changelog-btn">ğŸ“œ æ›´æ–°ç´€éŒ„</a>
<div id="version-display" class="version-badge">ç‰ˆæœ¬åµæ¸¬ä¸­...</div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script src="config.js"></script>
<script src="data.js"></script>

<script>
    // --- 1. è³‡æ–™å®‰å…¨æª¢æŸ¥ ---
    const safeSettings = (typeof mapSettings !== 'undefined') ? mapSettings : { imageName: "map_bg.jpg", minX: -2000, maxX: 10000, minY: -10000, maxY: 1000 };
    const safeData = (typeof rawData !== 'undefined') ? rawData : [];
    const safeHues = (typeof countyHues !== 'undefined') ? countyHues : {};

    // --- 2. åˆå§‹åŒ–åœ°åœ– ---
    const map = L.map('map', { 
        crs: L.CRS.Simple, 
        minZoom: -6, 
        maxZoom: 4, 
        zoomSnap: 0.1, 
        attributionControl: false 
    });

    // --- 3. å®šç¾©åœ–å±¤çµ„ ---
    const blankLayer = L.layerGroup().addTo(map); // é è¨­ç©ºç™½èƒŒæ™¯
    const villageLayer = L.layerGroup().addTo(map);
    const labelLayer = L.layerGroup().addTo(map); 
    const leaderLineLayer = L.layerGroup().addTo(map);
    const gridLayer = L.layerGroup().addTo(map);
    const railwayLayer = L.layerGroup().addTo(map);
    const railwayConstructionLayer = L.layerGroup();
    const mapImageLayer = L.imageOverlay(safeSettings.imageName, [[-safeSettings.minY, safeSettings.minX], [-safeSettings.maxY, safeSettings.maxX]], { opacity: 0.85 });

    // --- 4. å»ºç«‹åº§æ¨™ç´¢å¼•èˆ‡è¡Œæ”¿å€é¡è‰² ---
    const coordMap = {};
    const hierarchy = {};
    safeData.forEach(v => {
        coordMap[v.name] = [-v.y, v.x];
        if (!hierarchy[v.prov]) hierarchy[v.prov] = {};
        if (!hierarchy[v.prov][v.county]) hierarchy[v.prov][v.county] = new Set();
        hierarchy[v.prov][v.county].add(v.dist || "ç›´è½„");
    });
    
    const districtColors = {};
    Object.keys(hierarchy).forEach(prov => {
        Object.keys(hierarchy[prov]).forEach(county => {
            const districts = Array.from(hierarchy[prov][county]).sort();
            const baseHue = safeHues[county] || 0;
            districts.forEach((dist, index) => {
                const key = `${county}-${dist}`;
                districtColors[key] = (county === "æœªå®š") ? "#7f8c8d" : `hsl(${baseHue}, 80%, ${districts.length > 1 ? 35 + (index/(districts.length-1))*35 : 50}%)`;
            });
        });
    });

    // --- 5. ç¹ªè£½éµè·¯ (ä¿®æ­£ï¼šæ–°å¢åŸ·è¡ŒæŒ‡ä»¤) ---
    function drawRailways(routes, style, layer) {
        if(!routes) return;
        routes.forEach(routeStr => {
            const stations = routeStr.split("-");
            const latLngs = [];
            stations.forEach(name => { if (coordMap[name]) latLngs.push(coordMap[name]); });
            if (latLngs.length > 1) L.polyline(latLngs, style).addTo(layer);
        });
    }
    if(typeof railwayRoutesData !== 'undefined') {
        drawRailways(railwayRoutesData.completed, { color: '#333', weight: 3, opacity: 0.7 }, railwayLayer);
        drawRailways(railwayRoutesData.construction, { color: '#e67e22', weight: 3, opacity: 0.7, dashArray: '5, 10' }, railwayConstructionLayer);
    }

    // --- 6. ç¹ªè£½æ‘èŠæ¨™è¨˜èˆ‡æ¨™ç±¤ ---
    const labelObjects = [];
    const bounds = [];
    safeData.forEach(v => {
        const latLng = [-v.y, v.x];
        bounds.push(latLng);
        const distKey = v.dist || "ç›´è½„";
        const color = districtColors[`${v.county}-${distKey}`] || "#333";
        
        const popup = `<strong>${v.name}</strong><br>${v.prov}çœ ${v.county}ç¸£<br>åº§æ¨™: (${v.x}, ${v.y})`;
        L.circleMarker(latLng, { radius: 5, fillColor: color, color: "#000", weight: 1.5, fillOpacity: 1 }).bindPopup(popup).addTo(villageLayer);

        const line = L.polyline([latLng, latLng], { color: '#666', weight: 1, opacity: 0 }).addTo(leaderLineLayer);
        const label = L.marker(latLng, {
            icon: L.divIcon({ className: 'village-label-wrapper', html: `<div class="village-label-content">${v.name}</div>`, iconSize: [0, 0] }),
            draggable: true
        }).bindPopup(popup).addTo(labelLayer);
        
        label.on('drag', function(e) {
            line.setLatLngs([latLng, e.target.getLatLng()]);
            line.setStyle({opacity: 0.5});
            label.isManualMoved = true;
        });
        labelObjects.push({ marker: label, line: line, origin: latLng });
    });

    // --- 7. é¿è®“èˆ‡æ ¼ç·šå‡½æ•¸ ---
    function updateLabels() {
        const currentBounds = map.getBounds();
        const visible = [];
        labelObjects.forEach(obj => {
            if(!obj.marker.isManualMoved) obj.marker.setLatLng(obj.origin);
            if(currentBounds.contains(obj.origin)) {
                const pt = map.latLngToContainerPoint(obj.origin);
                visible.push({ obj, x: pt.x, y: pt.y, ox: pt.x, oy: pt.y });
            }
        });
        const forcePush = 30; 
        for(let k=0; k<15; k++) {
            visible.forEach(a => {
                if(a.obj.marker.isManualMoved) return;
                if (Math.sqrt(Math.pow(a.x-a.ox,2)+Math.pow(a.y-a.oy,2)) < forcePush) a.y -= 2;
                visible.forEach(b => {
                    if (a === b) return;
                    const dx = a.x - b.x, dy = a.y - b.y, d = Math.sqrt(dx*dx + dy*dy);
                    if (d < 45) { a.x += (dx/d)*2; a.y += (dy/d)*2; }
                });
            });
        }
        visible.forEach(item => {
            const newLatLng = map.containerPointToLatLng([item.x, item.y]);
            if(!item.obj.marker.isManualMoved) item.obj.marker.setLatLng(newLatLng);
            if (map.latLngToContainerPoint(item.obj.marker.getLatLng()).distanceTo([item.ox, item.oy]) > 12) {
                item.obj.line.setLatLngs([item.obj.origin, item.obj.marker.getLatLng()]);
                item.obj.line.setStyle({opacity: 0.5});
            } else { item.obj.line.setStyle({opacity: 0}); }
        });
    }

    function drawGrid() {
        gridLayer.clearLayers();
        const zoom = map.getZoom();
        let step = zoom >= 1 ? 100 : (zoom >= -1 ? 500 : 1000);
        const b = { minX: safeSettings.minX - 2000, maxX: safeSettings.maxX + 2000, minY: safeSettings.minY - 2000, maxY: safeSettings.maxY + 2000 };
        const style = { color: '#ccc', weight: 1, dashArray: '4, 4', opacity: 0.5 };
        
        for (let x = Math.floor(b.minX / step) * step; x <= b.maxX; x += step) {
            L.polyline([[-b.minY, x], [-b.maxY, x]], style).addTo(gridLayer);
            L.marker([-b.minY, x], { icon: L.divIcon({ className: 'grid-label', html: x, iconAnchor: [0, 15] }), interactive: false }).addTo(gridLayer);
        }
        for (let y = Math.floor(b.minY / step) * step; y <= b.maxY; y += step) {
            L.polyline([[-y, b.minX], [-y, b.maxX]], style).addTo(gridLayer);
            L.marker([-y, b.minX], { icon: L.divIcon({ className: 'grid-label', html: y, iconAnchor: [45, 5] }), interactive: false }).addTo(gridLayer);
        }
    }

    // --- 8. åˆå§‹åŒ–æ§åˆ¶èˆ‡äº‹ä»¶ ---
    L.control.layers({ "ç©ºç™½èƒŒæ™¯": blankLayer, "åœ°å½¢åœ–": mapImageLayer }, { "æ‘èŠé»ä½": villageLayer, "åç¨±æ¨™ç±¤": labelLayer, "æ ¼ç·š": gridLayer, "éµè·¯ (å·²é€šè»Š)": railwayLayer, "éµè·¯ (èˆˆå»ºä¸­)": railwayConstructionLayer }, { collapsed: false }).addTo(map);

    map.on('zoomend moveend', updateLabels);
    map.on('zoomend', drawGrid);

    map.whenReady(() => {
        drawGrid();
        updateLabels();
        if (bounds.length > 0) map.fitBounds(bounds, { padding: [50, 50] });
    });

    // --- 9. åœ–ä¾‹ ---
    const legend = L.control({position: 'bottomright'});
    legend.onAdd = function () {
        const div = L.DomUtil.create('div', 'legend');
        div.innerHTML = "<h4>ğŸ—ºï¸ è¡Œæ”¿å€åŠƒ</h4>";
        ["ä¸­äº¬", "æµ·åŒ—", "æœªå®š"].forEach(prov => {
            if (!hierarchy[prov]) return;
            div.innerHTML += `<div style="font-weight:bold; color:#d35400; margin-top:5px;">${prov}çœ</div>`;
            Object.keys(hierarchy[prov]).forEach(county => {
                Array.from(hierarchy[prov][county]).forEach(dist => {
                    const color = districtColors[`${county}-${dist}`];
                    div.innerHTML += `<div class="legend-item"><i class="legend-color" style="background:${color}"></i>${county}ç¸£ ${dist==='ç›´è½„'?'(ç›´è½„)':dist+'éƒ¡'}</div>`;
                });
            });
        });
        return div;
    };
    legend.addTo(map);

    // --- 10. éåŒæ­¥æŠ“å–ç‰ˆæœ¬ (GitHub API) ---
    (async function fetchVersion() {
        const display = document.getElementById('version-display');
        try {
            const host = window.location.hostname;
            const path = window.location.pathname.split('/').filter(x => x);
            if (host.includes('github.io')) {
                const user = host.split('.')[0];
                const repo = path[0] || "";
                const res = await fetch(`https://api.github.com/repos/${user}/${repo}/commits?per_page=1`);
                if (!res.ok) throw new Error();
                const data = await res.json();
                const date = new Date(data[0].commit.committer.date);
                display.innerText = "æœ€å¾Œæ›´æ–°: " + date.toLocaleString('zh-TW', { timeZone: 'Asia/Taipei', hour12: false });
            } else {
                display.innerText = "æœ¬åœ°æ¸¬è©¦æ¨¡å¼";
            }
        } catch (e) {
            display.innerText = "ç‰ˆæœ¬: æŠ“å–è¶…æ™‚";
        }
    })();
</script>
</body>
</html>
