<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ‘èŠåœ°åœ– - ç²¾æº–å°é½Šç‰ˆ</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <style>
        body { margin: 0; padding: 0; font-family: "Microsoft JhengHei", "Heiti TC", sans-serif; }
        #map { height: 100vh; width: 100vw; background-color: #f5f5f5; }
        
        .legend { background: rgba(255, 255, 255, 0.95); padding: 10px 15px; border-radius: 5px; border: 1px solid #bbb; box-shadow: 0 2px 5px rgba(0,0,0,0.1); font-size: 13px; max-height: 60vh; overflow-y: auto; line-height: 1.5; }
        .legend h4 { margin: 0 0 8px 0; font-size: 15px; border-bottom: 2px solid #666; padding-bottom: 5px; }
        .legend-item { display: flex; align-items: center; margin-bottom: 4px; }
        .legend-color { width: 16px; height: 16px; margin-right: 8px; border-radius: 50%; border: 1px solid #666; flex-shrink: 0; }
        .legend-line { width: 20px; height: 3px; margin-right: 8px; display: inline-block; vertical-align: middle; }
        
        .changelog-btn {
            position: absolute; top: 80px; left: 10px; z-index: 1000;
            background: white; border: 2px solid rgba(0,0,0,0.2); border-radius: 4px;
            padding: 5px 10px; font-size: 13px; font-weight: bold; color: #333;
            text-decoration: none; box-shadow: 0 1px 5px rgba(0,0,0,0.4);
            transition: 0.2s; display: flex; align-items: center;
        }
        .changelog-btn:hover { background: #f4f4f4; color: #007bff; }

        .grid-label { font-size: 10px; color: #999; white-space: nowrap; }
        .village-label-wrapper { background: transparent; border: none; }
        
        /* æ¨™ç±¤æ¨£å¼ï¼štranslate(-50%, -50%) é…åˆ JS å¼·åˆ¶ä½ç§» */
        .village-label-content { 
            position: absolute; left: 0; top: 0; transform: translate(-50%, -50%);
            display: inline-block; width: max-content; min-width: 40px; box-sizing: border-box; 
            font-size: 12px; font-weight: bold; color: #000; background-color: rgba(255,255,255,0.9); 
            padding: 3px 7px; border: 1px solid #666; border-radius: 4px; 
            white-space: nowrap; text-align: center; box-shadow: 1px 1px 4px rgba(0,0,0,0.2); 
            cursor: move; z-index: 600; user-select: none; pointer-events: auto;
        }
        .village-label-content:hover { background-color: #fff; border-color: #007bff; z-index: 700; box-shadow: 0 0 8px rgba(0,123,255,0.5); }
        
        .leaflet-popup-content { font-size: 14px; line-height: 1.6; }
        @media print { .leaflet-control-container, .changelog-btn { display: none !important; } #map { height: 100%; width: 100%; } }
    </style>
</head>
<body>

<div id="map"></div>
<a href="changelog.html" target="_blank" class="changelog-btn">ğŸ“œ æ›´æ–°ç´€éŒ„</a>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script src="config.js"></script>
<script src="data.js"></script>

<script>
    var safeSettings = (typeof mapSettings !== 'undefined') ? mapSettings : { imageName: "map_bg.jpg", minX: -2560, maxX: 8928, minY: -9728, maxY: 880 };
    var safeData = (typeof rawData !== 'undefined') ? rawData : [];

    const map = L.map('map', { crs: L.CRS.Simple, minZoom: -6, maxZoom: 4, zoomSnap: 0.1, attributionControl: false });
    
    const coordMap = {};
    safeData.forEach(v => { coordMap[v.name] = [-v.y, v.x]; });

    const hierarchy = {};
    safeData.forEach(v => {
        if (!hierarchy[v.prov]) hierarchy[v.prov] = {};
        if (!hierarchy[v.prov][v.county]) hierarchy[v.prov][v.county] = new Set();
        hierarchy[v.prov][v.county].add(v.dist || "ç›´è½„");
    });
    
    const districtColors = {}; 
    Object.keys(hierarchy).forEach(prov => {
        Object.keys(hierarchy[prov]).forEach(county => {
            const districts = Array.from(hierarchy[prov][county]).sort();
            const baseHue = (typeof countyHues !== 'undefined' && countyHues[county] !== undefined) ? countyHues[county] : 0;
            districts.forEach((dist, index) => {
                const key = `${county}-${dist}`;
                districtColors[key] = (county === "æœªå®š") ? "#7f8c8d" : `hsl(${baseHue}, 80%, ${districts.length > 1 ? 35 + (index / (districts.length - 1)) * 35 : 50}%)`;
            });
        });
    });

    const villageLayer = L.layerGroup().addTo(map);
    const labelLayer = L.layerGroup().addTo(map); 
    const leaderLineLayer = L.layerGroup().addTo(map);
    const gridLayer = L.layerGroup().addTo(map);
    const railwayLayer = L.layerGroup(); 
    const railwayConstructionLayer = L.layerGroup(); 

    // è¨ˆç®—é‚Šç•Œ
    let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
    safeData.forEach(v => {
        if (v.x < minX) minX = v.x; if (v.x > maxX) maxX = v.x;
        if (v.y < minY) minY = v.y; if (v.y > maxY) maxY = v.y;
    });
    const padding = 2000;
    const gridBounds = { minX: minX - padding, maxX: maxX + padding, minY: minY - padding, maxY: maxY + padding };

    function drawRailways(routes, style, layer) {
        if(!routes) return;
        routes.forEach(routeStr => {
            const stations = routeStr.split("-");
            const latLngs = [];
            stations.forEach(name => { if (coordMap[name]) latLngs.push(coordMap[name]); });
            if (latLngs.length > 1) L.polyline(latLngs, style).addTo(layer);
        });
    }
    if(typeof railwayRoutesData !== 'undefined') {
        drawRailways(railwayRoutesData.completed, { color: '#333', weight: 3, opacity: 0.8 }, railwayLayer);
        drawRailways(railwayRoutesData.construction, { color: '#e67e22', weight: 3, opacity: 0.8, dashArray: '5, 10' }, railwayConstructionLayer);
    }

    const bounds = [];
    const labelObjects = []; 

    safeData.forEach(v => {
        const latLng = [-v.y, v.x];
        bounds.push(latLng);
        const distKey = v.dist || "ç›´è½„";
        const color = districtColors[`${v.county}-${distKey}`] || "#333";
        
        const popupContent = `
            <div style="text-align:center; min-width: 160px;">
                <strong style="font-size:16px;">${v.name}</strong>
                <hr style="margin:5px 0; border-top:1px solid #ccc">
                <div style="font-size:12px;">${v.prov}çœ ${v.county}ç¸£ ${v.dist || '(ç›´è½„)'}</div>
                <div style="font-size:11px; color:#666; margin-top:4px;">åº§æ¨™: (${v.x}, ${v.y})</div>
                ${v.mapUrl ? `<div style="margin-top:8px;"><a href="${v.mapUrl}" target="_blank" style="color:#007bff; font-weight:bold; text-decoration:none;">æŸ¥çœ‹è»Œé“åœ– âœ</a></div>` : ''}
            </div>`;
        
        const marker = L.circleMarker(latLng, { radius: 5, fillColor: color, color: "#000", weight: 1.5, fillOpacity: 1 }).bindPopup(popupContent);
        villageLayer.addLayer(marker);

        const leaderLine = L.polyline([latLng, latLng], { color: '#666', weight: 1, opacity: 0, interactive: false });
        leaderLineLayer.addLayer(leaderLine);

        const labelMarker = L.marker(latLng, {
            icon: L.divIcon({ className: 'village-label-wrapper', html: `<div class="village-label-content">${v.name}</div>`, iconSize: [0, 0] }),
            draggable: true
        }).bindPopup(popupContent);
        
        labelMarker.on('drag', function(e) {
            leaderLine.setLatLngs([latLng, e.target.getLatLng()]);
            leaderLine.setStyle({opacity: 0.6});
            labelMarker.isManualMoved = true;
        });
        labelLayer.addLayer(labelMarker);

        labelObjects.push({ marker: labelMarker, line: leaderLine, origin: latLng });
    });

    // æ ¸å¿ƒæ¼”ç®—æ³•ï¼šä¿®æ­£é«˜å€ç‡ä¸è¦†è“‹åœ“é»
    function updateLabels() {
        const currentBounds = map.getBounds();
        const visibleLabels = [];
        
        labelObjects.forEach(obj => {
            if(!obj.marker.isManualMoved) {
                obj.marker.setLatLng(obj.origin); // å…ˆé‡ç½®å›åŸä½
            }
            if(currentBounds.contains(obj.origin)) {
                const pt = map.latLngToContainerPoint(obj.origin);
                visibleLabels.push({ obj, x: pt.x, y: pt.y, ox: pt.x, oy: pt.y });
            }
        });

        const minDist = 45; // æ¨™ç±¤é–“è·
        const forcePushFromCenter = 30; // [é—œéµ] å¼·åˆ¶é›¢é–‹åœ“é»ä¸­å¿ƒçš„æœ€å°åƒç´ è·é›¢

        for(let k=0; k<15; k++) {
            visibleLabels.forEach(a => {
                if(a.obj.marker.isManualMoved) return;

                // 1. å¼·åˆ¶æ¨é›¢è‡ªå·±çš„åœ“é»ä¸­å¿ƒ (é¿å…è¦†è“‹)
                const dxCenter = a.x - a.ox;
                const dyCenter = a.y - a.oy;
                const distCenter = Math.sqrt(dxCenter*dxCenter + dyCenter*dyCenter);
                
                if (distCenter < forcePushFromCenter) {
                    // å¦‚æœå¤ªé è¿‘ä¸­å¿ƒï¼Œé è¨­å¾€ä¸Šæ–¹æ¨
                    if (distCenter < 1) { a.y -= 2; } 
                    else {
                        const ratio = forcePushFromCenter / distCenter;
                        a.x = a.ox + dxCenter * ratio;
                        a.y = a.oy + dyCenter * ratio;
                    }
                }

                // 2. æ¨™ç±¤å½¼æ­¤é–“çš„é¿è®“
                visibleLabels.forEach(b => {
                    if (a === b) return;
                    const dx = a.x - b.x;
                    const dy = a.y - b.y;
                    const d = Math.sqrt(dx*dx + dy*dy);
                    if (d < minDist) {
                        const s = (minDist - d) / 2;
                        const ax = (dx/d)*s, ay = (dy/d)*s;
                        a.x += ax; a.y += ay;
                        if(!b.obj.marker.isManualMoved) { b.x -= ax; b.y -= ay; }
                    }
                });
            });
        }

        visibleLabels.forEach(item => {
            const newLatLng = map.containerPointToLatLng([item.x, item.y]);
            if(!item.obj.marker.isManualMoved) {
                item.obj.marker.setLatLng(newLatLng);
            }
            
            const dist = map.latLngToContainerPoint(item.obj.marker.getLatLng()).distanceTo([item.ox, item.oy]);
            if (dist > 12) {
                item.obj.line.setLatLngs([item.obj.origin, item.obj.marker.getLatLng()]);
                item.obj.line.setStyle({opacity: 0.5});
            } else {
                item.obj.line.setStyle({opacity: 0});
            }
        });
    }

    map.on('zoomend moveend', updateLabels);
    map.whenReady(() => setTimeout(updateLabels, 300));

    function drawGrid() {
        gridLayer.clearLayers();
        const zoom = map.getZoom();
        let step = zoom >= 1 ? 100 : (zoom >= -1 ? 500 : (zoom >= -3 ? 1000 : 2000));
        for (let x = Math.floor(gridBounds.minX / step) * step; x <= gridBounds.maxX; x += step) {
            gridLayer.addLayer(L.polyline([[-gridBounds.startY || -9728, x], [-gridBounds.maxY || 880, x]], {color:'#ccc', weight:1, dashArray:'4,4'}));
            gridLayer.addLayer(L.marker([-gridBounds.minY, x], { icon: L.divIcon({className: 'grid-label', html: x, iconSize:[40,10]}) }));
        }
        for (let y = Math.floor(gridBounds.minY / step) * step; y <= gridBounds.maxY; y += step) {
            gridLayer.addLayer(L.polyline([[-y, gridBounds.minX], [-y, gridBounds.maxX]], {color:'#ccc', weight:1, dashArray:'4,4'}));
        }
    }
    drawGrid();
    map.on('zoomend', drawGrid);

    const mapImageLayer = L.imageOverlay(safeSettings.imageName, [[-safeSettings.minY, safeSettings.minX], [-safeSettings.maxY, safeSettings.maxX]], { opacity: 0.9 });
    const blankLayer = L.layerGroup();
    L.control.layers({ "ç©ºç™½èƒŒæ™¯": blankLayer, "åœ°å½¢åœ–": mapImageLayer.addTo(map) }, { "æ‘èŠé»ä½": villageLayer, "åç¨±æ¨™ç±¤": labelLayer, "å¼•å°ç·š": leaderLineLayer, "æ ¼ç·š": gridLayer, "éµè·¯ (é€šè»Š)": railwayLayer.addTo(map), "éµè·¯ (èˆˆå»º)": railwayConstructionLayer }).addTo(map);
    if (bounds.length > 0) map.fitBounds(bounds, { padding: [50, 50] });

    const legend = L.control({position: 'bottomright'});
    legend.onAdd = function () {
        const div = L.DomUtil.create('div', 'legend');
        div.innerHTML = "<h4>ğŸ—ºï¸ è¡Œæ”¿å€åŠƒ</h4>";
        ["ä¸­äº¬", "æµ·åŒ—", "æœªå®š"].forEach(prov => {
            if (!hierarchy[prov]) return;
            div.innerHTML += `<div style="font-weight:bold; color:${prov==='ä¸­äº¬'?'#d35400':'#2980b9'}">${prov}</div>`;
            Object.keys(hierarchy[prov]).forEach(county => {
                Array.from(hierarchy[prov][county]).forEach(dist => {
                    const color = districtColors[`${county}-${dist}`];
                    div.innerHTML += `<div class="legend-item"><i class="legend-color" style="background:${color}"></i>${county}ç¸£ ${dist==='ç›´è½„'?'(ç›´è½„)':dist+'éƒ¡'}</div>`;
                });
            });
        });
        return div;
    };
    legend.addTo(map);
</script>
</body>
</html>
